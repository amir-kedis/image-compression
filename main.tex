\documentclass{report}
\usepackage{titling}
\usepackage{natbib} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry} 

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\title{Signals Analysis Project 2024}
\author{Ahmed Hamdy 9220032 \\ Amir Kedis 9220166}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    {\LARGE \textbf{\thetitle} \par}
    \vspace{0.25cm}
    {\LARGE Image Compression \& Decompression}
    \vspace{1.0cm}

    {\large Cairo University \\ Faculty Of Engineering \\ Computer Department \par}
    \vspace{1.0cm}
    {\LARGE \textbf{\theauthor} \par}
    \vspace{1.5cm}
    {\Large \textbf{Delivered to} \\ 
    Dr. Michael Melek \\\vspace{0.2cm}
    Eng. Sayed Kamel} 
    
    \vfill
\end{titlepage}

\tableofcontents

\newpage
\chapter{Compression}

\section{Import Necessary Libraries}
\lstset{style=mystyle}
\begin{lstlisting}[language=Python, caption=import necessary libraries,label=lst:import-libraries]
import os
import cv2
import numpy as np
from scipy.fft import dct
import matplotlib.pyplot as plt
\end{lstlisting}

\section{Extract Colors Channels}
\lstset{style=mystyle}
\begin{lstlisting}[language=Python, caption=extract rgb components,label=lst:rgb-extract]
#Function to get the rgb channels of the image 
def color_channel_extraction(img):
    colors = ["Reds","Greens","Blues"]
    for i in range(3):
        plt.figure(figsize=(16, 8))
        plt.imshow(img[:,:,2-i],cmap=colors[i])
        plt.colorbar() #use a color bar to display the intensity of the channel
        plt.axis("off")
        plt.savefig(f"{colors[i][0]}_channel.png")
\end{lstlisting}

\newpage

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{R_channel.png}
    \caption{R component}
    \label{fig:R-channel}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{G_channel.png}
    \caption{G component}
    \label{fig:G-channel}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{B_channel.png}
    \caption{B component}
    \label{fig:B-channel}
\end{figure}

\newpage

\chapter{Compression}
\section{2D DCT Formula}
\begin{equation}
\label{eq:2d-dct}
C(u,v) = a_u a_v \sum_{y=0}^{N-1} \sum_{x=0}^{M-1} \cos \left( \frac{2x+1}{2M} u\pi \right) \cos \left( \frac{2y+1}{2N} v\pi \right)
\end{equation}
\hspace{6cm}where $0 \leq u \leq M - 1$ and $0 \leq v \leq N - 1$.

\vspace{0.5cm}
The formula for \( a_u \) is given by:
\begin{equation}
a_u = 
\begin{cases}
\frac{1}{\sqrt{N}}, & \text{if } u = 0 \\
\sqrt{\frac{2}{N}}, & \text{if } 1 \leq u \leq N - 1
\end{cases}
\end{equation}

\vspace{0.5cm}
Similar for  $ a_v$

\section{Compress Given $m$ Value}

We handle every color channel within the image matrix as a set of 8x8 pixels blocks. Applying the 2D Discrete Cosine Transform (2D DCT) on each block enables us to isolate the lower frequencies. Consequently, we can disregard the remaining frequencies and solely retain the significant ones for storage.
\lstset{style=mystyle}
\begin{lstlisting}[language=Python, caption=compress image given m,label=lst:compress-img-helper]
#Function to compress the image given the size of the processed block(m)
def compress_img_helper(img,m):
    blockNumForHeight=img.shape[0]//8 # integer division to get the number of 8*8 blocks that can fit in the height of the img
    blockNumForWidth=img.shape[0]//8 # integer division to get the number of 8*8 blocks that can fit in the height of the img
    compressed = np.zeros((m*blockNumForHeight,m*blockNumForWidth,3))
    for channel in range(3):
        for row in range(blockNumForHeight):
            for col in range(blockNumForWidth):
                blockToProcess = img[8*row:8*(row+1),8*col:8*(col+1),channel]
                proccessedBlock = dct(dct(blockToProcess.T, norm='ortho').T, norm='ortho') #2d DCT
                compressed[m*row:m*(row+1),m*col:m*(col+1),channel] = proccessedBlock[:m,:m]
    return compressed
\end{lstlisting}

\newpage

\section{Compare Sizes}
\begin{table}[h]
    \centering
    \caption{Sizes Table}
    \label{tab:Sizes}
    \begin{tabular}{|c|c|} 
        \toprule
        \textbf{File} & \textbf{Size In Bytes} \\ 
        \midrule 
            Original image  & 3588902  \\ \hline
            Compressed image (m=1)  &10217  \\ \hline
            Compressed image (m=2)  & 117121  \\ \hline
            Compressed image (m=3)  & 246717  \\ \hline
            Compressed image (m=4) & 402654  \\ \hline
    \end{tabular}
\end{table}


\lstset{style=mystyle}
\begin{lstlisting}[language=Python, caption=compress img given m,label=lst:compress-img-helper]
#Function to compare between the original & compressed sizes
def compare_sizes():
    original_size = os.path.getsize("image1.png")
    print(f"Original image size: {original_size} bytes")
    
    with open("image_sizes.txt", "w") as file:
        file.write(f"Original image size: {original_size} bytes\n")
        
        for m in range(1, 5):
            compressed_path = f"compressed/compressed_m{m}.png"
            compressed_size = os.path.getsize(compressed_path)
            print(f"Compressed image (m={m}) size: {compressed_size} bytes")
            file.write(f"Compressed image (m={m}) size: {compressed_size} bytes\n")
\end{lstlisting}



\chapter{Decompression}

\chapter{Results}

\appendix
\chapter{Appendix}
\section{Code}
\begin{lstlisting}[language=Python, caption=extract rgb components,label=lst:code]
import numpy as np
import matplotlib.pyplot as plt
import cv2
import os
from scipy.fft import dct


#Function to get the rgb channels of the image 
def color_channel_extraction(img):
    colors = ["Reds","Greens","Blues"]
    for i in range(3):
        plt.figure(figsize=(16, 8))
        plt.imshow(img[:,:,2-i],cmap=colors[i])
        plt.colorbar() #use a color bar to display the intensity of the channel
        plt.axis("off")
        plt.savefig(f"{colors[i][0]}_channel.png")


#Function to compress the image given the size of the processed block(m)
def compress_img_helper(img,m):
    blockNumForHeight=img.shape[0]//8 # integer division to get the number of 8*8 blocks that can fit in the height of the img
    blockNumForWidth=img.shape[0]//8 # integer division to get the number of 8*8 blocks that can fit in the height of the img
    compressed = np.zeros((m*blockNumForHeight,m*blockNumForWidth,3))
    for channel in range(3):
        for row in range(blockNumForHeight):
            for col in range(blockNumForWidth):
                blockToProcess = img[8*row:8*(row+1),8*col:8*(col+1),channel]
                proccessedBlock = dct(dct(blockToProcess.T, norm='ortho').T, norm='ortho') #2d DCT
                compressed[m*row:m*(row+1),m*col:m*(col+1),channel] = proccessedBlock[:m,:m]
    return compressed

#Function to compare between the original & compressed sizes
def compare_sizes():
    original_size = os.path.getsize("image1.png")
    print(f"Original image size: {original_size} bytes")
    
    with open("image_sizes.txt", "w") as file:
        file.write(f"Original image size: {original_size} bytes\n")
        
        for m in range(1, 5):
            compressed_path = f"compressed/compressed_m{m}.png"
            compressed_size = os.path.getsize(compressed_path)
            print(f"Compressed image (m={m}) size: {compressed_size} bytes")
            file.write(f"Compressed image (m={m}) size: {compressed_size} bytes\n")

#Function to perform the whole compressison process 
def compress_img():
    img = cv2.imread("image1.png")
    color_channel_extraction(img)
    os.makedirs("compressed", exist_ok=True)
    for m in range(1, 5):
        compressed_img = compress_img_helper(img, m)
        # Scale pixel values back to 0-255 range
        compressed_img = np.clip(compressed_img, 0, 255).astype(np.uint8)
        # Convert BGR to RGB if needed
        if len(compressed_img.shape) == 3 and compressed_img.shape[2] == 3:
            compressed_img = cv2.cvtColor(compressed_img, cv2.COLOR_BGR2RGB)
        cv2.imwrite(f"compressed/compressed_m{m}.png", compressed_img)  # Save the compressed image
    compare_sizes()

compress_img()
\end{lstlisting}
\section{Appendix B}
More appendix content goes here.
\bibliographystyle{plain}
\bibliography{references}

\end{document}
